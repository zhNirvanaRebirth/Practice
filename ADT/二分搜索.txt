二分搜索
	数组已排序
	
分析
	是不是排好序的
	有没有重复
	有没有负数
	
搜索目标值的第一个位置
搜索目标值的最后一个位置

模板
	def binarysearch(alist, item):
		if len(alist) == 0:
			return -1
			
		left, right = 0, len(alist) - 1
		while left = 1 < right:
			mid = left + (right - left) // 2
			if alist[mid] == item:
				right = mid
			elif alist[mid] < item:
				left = mid
			elif alist[mid] > item
				right = mid
		if alist[left] == item:
			return left
		if alist[right] == item:
			return right
		return -1 
		
在旋转有序数列中查找最小值(如：4567123)

搜索插入位置
	给定一个有序数组和一个目标值，在数组中查找该目标值，找到就返回其index，没找到就返回目标值应该被插入的位置index
	
	就是找到第一个大于等于目标值的数
	
搜索一个区间（包含重复数字的已排序数组）
	找到一个给定目标值的开始和结束位置
	
在无限有序数列中找到某元素第一次出现的位置
	数据流
	不知道序列的长度
	
	依次扩展L和R
	
供暖设备
	给定两个数组，一个是房屋位置index， 一个是供暖设备index，求能给所有房屋供暖的情况下的供暖设备的最小供暖半径
	
	对供暖设备位置进行排序
	对每个房子找到第一个位置大于自己的供暖设备index （使用上题方法）
	找到每个房子的最小供暖半径
	对所有房子的最小供暖设备半径取最大值
	
矩阵搜索
	给定N*M的矩阵，每一行和每一列都是已排序的，从中查找指定值
	
	从矩阵的左下/右上角开始找
	时间复杂度O(m+n)
	
矩阵搜索
	查找第k大的数字
	
	使用minheap：首先将a[0][0]加入小顶堆，然后每次从小顶堆中取出最小元素，并加入比该元素大且与之相邻的两个元素（对于a[0][0]，则需要加入 a[0][1]和a[1][0]），直到取出第k个元素
	
层高和鸡蛋
	100层楼，2个鸡蛋，n层以上摔鸡蛋，会碎，以下不会，利用这两个鸡蛋找到n
	
	主要是找到开始楼层
		x + (x-1) + (x-2) + ... > 100 得到x=14
		
	扩展：1000层楼，3个鸡蛋
	
找到两个有序数组的中值（两个数组大小不相同）
找到两个有序数组的中值（两个数组大小相同）