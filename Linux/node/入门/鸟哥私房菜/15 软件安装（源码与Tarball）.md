# 软件安装：源码与Tarball  
## 开放源码的软件安装与升级  
> Linux上的软件几乎都是经过GPL的授权，因此每个软件都提供了原始程序，并且我们可以自行修改程序，以符合个人的需求  
  
### 可执行文件  
> Linux系统中能不能执行一个文件，需要看有没有对该文件的执行权限，当然，前提是该文件是一个可执行文件，Linux系统真正认识的可执行文件其实是二进制文件(binary program),可通过指令"file 文件名"查看文件是否为可执行文件  
  
要获得可执行的binary程序，我们需要通过编辑器编写程序源码，将源码编译成系统看的懂的binary program  
### 函数库  
> 函数库包括静态函数库与动态函数库，Linux核心提供了很多核心相关的函数库与外部参数，这些核心功能在设计硬件的驱动程序是非常有用，相关的文件位置：/usr/include,/usr/lib,/usr/lib64  
  
### make与configure  
1. 我们在执行make时，make会在当前目录下搜索Makefile文件，Makefile文件中记录了原始码如何编译的详细信息，make会自动判断原始码是否经过变动而自动更新执行文件  
2. configure(config)是一个测试程序的文件，用于测试操作环境是否有软件开发商所需要的其他功能，当测试完毕之后，就会主动建立其软件需要的Makefile  
  
configure侦测程序会侦测的内容：  
* 是否有适合编译器可以编译该软件的程序码  
* 是否已经存在该软件所需要的函数库或者其他相依的软件  
* 操作系统是否适合该软件，包括Linux的核心版本  
* 核心表头定义文件(header include)是否存在  
### Tarball软件  
> 程序源码文件就是写了程序源码的文字文件，这是一种比较浪费空间的文件格式，Tarball文件就是将软件的所有源码文件先tar打包，再使用压缩技术进行压缩，比如常见的gzip，所以其一般后缀名为*.tar.gz或者*.tgz  
  
Tarball软件包解压之后包括的文件：  
* 源代码文件  
* 侦测程序文件(configure/config)  
* 软件的说明与安装说明(INSTALL/README)  
### 软件的安装与升级  
* 直接以源码通过编译来安装或升级  
* 直接以编译好的binary program来安装或升级  
### 编译生成binary program的步骤  
1. 使用gcc进行源码的编译（会生成目标文件object files）  
2. 通过gcc进行函数库、主程序、副程序的连接，形成主要的binary file  
### gcc的一般用法  
* gcc -c hello.c:编译源码，生成对应的目标文件(hello.o)，但不会生成binary执行文件  
* gcc -o hello hello.o:将目标文件生成对应的binary file  
* gcc -O -c hello.c:编译源码,生成最佳化参数的目标文件(hello.o) 
* gcc -o thanks thanks1.o thanks2.o:将目标当连接制作成一个binary执行文件  
* gcc sin.c -lm -L/lib64 -I/usr/include:-lm表示编译时加入额外的函数库("-l"表示加入某个函数库(library)的意思，"m"表示"libm.so"或"libm.a",就是去掉函数库开头的"lib"和后缀名(".so",".a"))；-L表示在哪里搜索-l加入的函数库；-I表示源码(sin.c)中include导入的"*.h"文件所在的目录  
## 使用make进行巨集编译  
> 当我们需要对多个具有相关性的源码进行编译时，进行的操作会比较繁琐，而且当我们仅修改了当中部分文件之后，需要重新编译时，又要将编译步骤再走一次，此时我们可以通过编辑Makefile文件，使用make工具简化上述操作  
  
在Makefile文件中，我们只需要写出binary file需要的目标文件(*.o)，make会主动判断每个目标文件相关的源码文件，并将其编译，再将连接动作写上即可  
如果我们修改了某些源码文件，再次执行make时，make会主动判断哪些源码与相关的目标文件有更改，并更新该文件，这样，可以大大的节省编译的时间  
make的好处：  
* 简化编译时需要下达的指令  
* 在编译完成之后，修改了某些源码文件，make会针对被修改的文件进行编译，其他object file不会被更改  
* 最后可以依照相依性来更新(update)执行文件  
### Makefile的基本语法与变量  
基本语法：  
```  
target:目标文件1 目标文件2  
<tab>gcc -o 执行文件名 目标文件1 目标文件2  
```  
"target"表示要建立的信息，后面就是我们需要的有相依性的object file，而命运行的开头必须以tab键开头，基本规则如下：  
* "#"后面的内容为注释  
* 命令行的开头必须时tab键（比如这里的gcc编译指令）  
* target与object file之间需要使用":"隔开  

变量使用：  
* 变量与变量内容以"="隔开，"="两边可以有空格  
* 变数左边不能有tab，也就是变量的定义行首不能以tab键开头  
* 变量与变量内容在"="两边不能使用":"  
* 变量一般使用大写  
* 通过"${变量}"或"$(变量)"方式使用变量  
* 在Makefile中可以使用环境变量  
* 在执行make的指令中可以指定变量  
  
Makefile变量使用规则：  
1. make指令后加上的环境变量优先级最高  
2. Makefile中指定的变量优先级次之  
3. shell原本具有的环境变量优先级最低  
  
特殊变量：  
* $@:代表目前的target  
  
## Tarball的管理  
### 制作一个binary program需要的基础软件  
* gcc或cc等C语言编译器(compiler)  
* make及autoconfig等软件  
* Kernel提供的Library以及相关的Include文件  
### Tarball安装的基本步骤  
> Tarball方式提供的软件时需要重新编译成可执行的binary program的，而Tarball是以tar指令打包与压缩的文件，所以需要先进行Tarball的解压，然后到源码目录下建立Makefile文件，在执行make进行编译与安装  
  
1. 取得Tarball并将其解压到/usr/local/src目录下  
2. 进入解压的目录下，查看INSTALL与README文件内容  
3. 相依性软件安装，根据INSTALL与README中的内容安装  
4. 建立Makefile：以自动检测程序(configure或config)侦测操作系统，建立Make file文件  
5. 编译：使用make指令根据该目录下的Makefile文件设定来进行编译等操作  
6. 安装  
## 函数库管理  
> 软件之间可以通过彼此提供的函数库运行特殊的功能，函数库依据是否被编译到程序内部而分为动态函数库和静态函数库  
  
### 静态(Static)函数库  
* 后缀名为".a"  
* 编译行为：在编译的时候被直接整合到执行文件中（因此使用静态函数库会使编译的执行文件变大）  
* 使用静态函数库，编译成功之后的执行文件可以独立执行，不需要再向外部要求读取函数库的内容  
* 静态函数库升级时，使用静态函数库的执行文件必须将整个执行文件进行重新编译  
### 动态(Dynamic)函数库  
* 后缀名为".so"  
* 动态函数库不会被编译到执行文件中，在程序中有一个函数库的指向(Pointer)的位置，只是在程序执行时，需要读取函数库的机制时，才会去读取函数库  
* 执行文件使用了动态函数库就不能独立执行，函数库必须存在，而且所在的目录不能改变  
* 函数库可进行升级，不需要重新编译执行文件  
  
函数库的位置：  
* 一般函数库的位置：/lib或/lib64目录下  
* Kernel提供的函数库位置：/lib/modules  
### ldconfig与/etc/ld.so.conf  
> 执行文件使用了动态函数库时，会有需要读取函数库的时候，而内存的读取速度比磁盘的读取速度快很多，因此，如果我们将常用的动态函数库载入内存中(cache),这样当软件使用函数库时，就能进行快速的读取，这就需要ldconfig和/etc/ld.so.conf的设定了  
  
相关设定步骤：  
1. 将需要读入内存中的动态函数库所在的目录写入/etc/ld.so.conf文件中  
2. 使用ldconfig执行文件将/etc/ld.so.conf中的读入内存的cache中  
3. 同时将资料记录一份在/etc/ld.so.cache文件中  
