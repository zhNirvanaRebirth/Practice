# 磁盘与档案系统管理  
## 硬盘磁盘的相关知识  
* 磁区(Sector)为最小的物理存储单位，主要大小格式有两种，512bytes和4k  
* 将磁区组成一个圆，就是一个磁柱(Cylinder)  
* 早期的分割主要以磁柱为最小分割单位，现在的分割通常以磁区为最小分割单位  
* 磁盘分割主要有两种格式：MBR(Master boot record)和GPT磁盘分割表(GUID partition table, GPT)  
## 文档系统特性  
* 磁盘分区完成后必须进行格式化才能成为操作系统可以使用的文档系统格式  
* 传统的磁盘与档案系统中，一个分区只能格式化成为一种文档系统，在这种情况下，一个文件系统就是一个分区，但是现在，一个分区可以格式化成为多个文件系统，也能将多个分区格式化成为一种文件系统，因此我们通常称一个可被挂载的资料为一个档案系统，而不是一个分区为一个档案系统  
## Linux文件系统  
操作系统中的文件资料除了文件实际内容之外，还有非常多的属性，例如文件权限与文件属性(拥有者，群组和时间参数等)，文件系统通常将这两部分资料存放到不同的区块中，权限和属性存放到inode中，实际内容存放到data block区块中，另外，超级区块(superblock)会记录整个档案系统的整体资讯，包括inode与block的总量，使用量和剩余量  
* superblock:记录filesystem的整体资讯，包括inode和block的总量，使用量和剩余量，以及文件系统的格式和相关资讯  
* inode:记录文件的属性，一个文件占用一个inode，同时记录此文件资料所在的block号码  
* block:存放文件的时间内容，若文件太大，会占用多个block  
**在文件系统中，每个inode和block都有一个编号，而每个文档都会占用一个inode，每个inode中记录了放置该文件资料的block编号，因此，我们只有找到文件的inode，就能找到存放资料的block编号，从而找到文件的实际内容**  
### Linux上的EXT2文件系统  
> 文件系统一开始就将inode和block规划好了（除非重新格式化或者利用resize2fs指令修改文件系统的大小），所以inode和block固定后就不再改变  
  
由于我们的文件系统可能会有数百G的大小，此时将所有的inode和block放置在一起就不便于管理了，因此ext2文件系统在格式化的时候，会将区分为多个区块群组(block group)，每个群组里面都有独立的inode/block/superblock,每个区块群组的具体内容如下：  
1. data block：资料区块，就是用来存放资料实际内容的地方，ext2文件系统中支持的block的大小分为1k，2k和4k，这个大小在文件系统格式化的时候就已经确定，且每个block都有自己的编号，由于每个block的大小不同，会限制系统能存储的单一文档和系统总容量的大小(具体计算方式需要结合inode记录block的规则)  
#### ext2文件系统中对block的基本限制  
* block的大小和数量在格式化之后就不能再进行改变了（除非重新进行格式化）  
* 每个block中最多只能放置一个文件资料  
* 如果文件资料大于block的大小，则该文件会占用多个block  
* 如果文件资料小于block的大小，则该block中剩下的容量就不能再被别的文件使用了（磁盘空间浪费）  
**由于以上的限制，我们在格式化文件系统的时候，就需要根据文件系统的用途等使用情况，规划好block的大小，否则，单个block的容量太大，会造成磁盘空间浪费，若是太小，一个文件需要很多block，则会操作inode需要记录很多block，损失读写效率**  
2. inode table：每个文件都会占用一个inode，而所有的inode都在inode table中，每个inode中记录了文件的属性和存放文件实际内容的block编号，inode记录的详细内容如下：  
* 该档案的存取模式(read/write/excute)  
* 该档案的拥有者群组  
* 该档案的容量  
* 该档案的建立或状态改变时间(ctime)  
* 该档案最近一个读取时间(atime)  
* 该档案最小修改时间(mtime)  
* 档案特性相关的标志(flag),如SetUID等  
* 档案真正内容的指向(pointer)  
* 每个inode的大小在格式化时就固定了，在ext2中每个inode的大小为128bytes（ext4和xfs可以设定为256bytes）  
* 每个文件只会占用一个inode  
* 文件系统在格式化之后，其inode的数量就已经固定了，因此，文档系统中能建立的文件数量和inode的数量有关  
* 系统在读取档案时，需要先找到inode，并分析所记录的权限和使用者是否符合，若符合才继续读取block的内容  
**inode的大小只有128bytes，需要记录文件的属性，除此之外还需要记录存放文件实际内容的block编号，记录每个编号需要花费4bytes的大小，因此就算inode全用来记录block的编号，也只能记录32个block，而我们的文件内容很可能没法用32个block就存储完，所以inode记录block的编号采用12个直接，1一个间接，1一个双间接，一个三间接来记录block的编号（这里就是计算上个单个block大小不同，影响单个文件最大存储大小的来由）**  
3. superblock：记录整个filesystem相关资讯的地方，没有superblock，就没有这个filesystem了，其记录的主要资讯有：  
* block和inode的总量  
* 已使用和未使用的inode和block的数量  
* block和inode的大小（block为1，2，4k，inode为128，256bytes）  
* filesystem的挂载时间，最后一次写入资料的时间（注意：inode中记录的是其记录档案的相关时间），最后一次检验磁盘的时间等文件系统的相关资讯  
* 一个valid bit数值，若此文件系统已挂载，valid bit为0，否则为1  
* 一般superblock的大小是1024bytes，可以通过dumpe2fs指令来查看其资讯  
* 文件系统将区分成了多个block group，而每个block group中都有可能含有superblock，而每个文件系统中应该只有一个superblock，所以除了第一个block group之外，后面的block group不一定有superblock，就算有，也是第一个block group中的superblock的备份  
4. Filesystem Description:文件系统描述说明，可以描述每个block group的开始与结束block的编号  
5. block bitmap：记录使用与未使用的block的编号，当我们需要新增文件时，就需要未使用的block来存储，这时，就需要从block bitmap中查看空的block，当我们需要删除某个文件时，文件占用的block就会释放出来，此时block bitmap中相应的block号码标志就会改成未使用  
6. inode bitmap：记录已使用和未使用的inode编号  
## 目录树  
* 目录：当我们在Linux的文件系统中建立一个目录时，文件系统会分配一个inode和至少一块block给该目录，其中inode用来记录该目录的权限与属性以及block的编号，而block是用来存储这个目录下的文档名和文档名占用的inode的编号  
* 文件：当我们在ext2建立一个一般的文件时，系统会分配一个inode和相对于档案大小个数的block给该文件，inode中会记录该文件的属性和block的编号  
* inode中不记录文件的名字，记录文件名的地方在目录的block中，因此我们要对一个文件进行新增/删除/更改名字时，需要有对该文件所在目录有write权限，因为我们在修改文件名等操作的时候需要修改上层目录的block中的信息  
**当我们要读取某个文件时，系统通过挂载的资讯可以找到挂载点的inode编号，此时就能够找到目录树的根目录的inode，通过inode找到根目录的block，读取其中的内容，然后逐层往下找到需要的文档**  
### 新增一个文件时系统的行为  
1. 判断使用者对想新增文件的目录是否具有w与x权限，若有才能新增  
2. 找到一个inode bitmap中的未使用的inode号码，将新增文件的权限和属性写入  
3. 找到对应文件大小数量的block bitmap中的block号码，将文件的实际内容写入，且更新inode中block的指向  
4. 将刚刚写入的inode和block的资料同步更新到inode bitmap和block bitmap中，并更新superblock中的内容  
### 日志式文件系统(Journaling filesystem)  
我们在新增文档等操作时，若发现不正常的情况，就可能导致资料的不一致(Inconsistent)状态，所以我们需要一个区块来专门记录写入和修改文件时的步骤，以便做文件的一致性检测  
日志式文件系统的一致性检查步骤：  
1. 预备：当系统要写入一个文件时，会先在日志记录区块中记录某个文件准备要写入的资讯  
2. 实际写入：开始写入文件的权限与资料，开始更新metadata（inode bitmap, block bitmap, superblock）的资料  
3. 结束：完成资料与metadata的更新后，在日子记录区块完成该文件的记录  
### Linux文件系统的运作  
假如我们在向一个文件中写入数据，如果我们在编辑的过程中又频繁的让系统将数据写到磁盘中，由于磁盘的写入速度比内存慢很多，所有这样做肯定是没效率的，所以Linux使用的方式是一种称为非同步处理(asynchronously)的方式  
> 非同步处理：系统载入一个文件到内存中后，如果该文件没有被更改过，则在内存区段中该文件会被设置成干净(clean)的,若资料被修改过了，则会被设定为脏(dirty)的，这里的所有操作都是在内存中执行，并没有写入磁盘，系统会不定时的将内存中脏的数据写回磁盘，以保证资料的一致性，我们也可以使用"sync"命令来手动将脏资料写回磁盘  
  
文件系统的其他运作：  
* 系统会将常用的文件资料放置到内存的缓冲区，以加速文件系统的读写  
* Linux的内存可能会被用光，这是正常的情况  
* 我们可以手动的使用指令"sunc"来将被内存设定为脏的数据写回磁盘  
* 正常关机时，关机指令会主动调用sync指令来将内存中的脏数据写回磁盘  
* 不正常关机时，内存中的资料不能写回磁盘，重启机器后可能会花很多时间进行磁盘检查，甚至可能造成文件系统的损坏  
## 挂载点  
每个filesystem都拥有独立的inode/block/superblock等信息，而文件系统必须能够连接到目录树才能被我们使用，将文件系统和目录树结合的动作称为挂载  
> 挂载点一定是目录，该目录是进入该文件系统的入口  
  
## Linux支持的文件系统  
* 查看当前Linux支持的文件系统命令：ls -l /lib/modules/$(uname -r)/kernel/fs  
* 查看系统当前已载入到内存的文件系统命令：cat /proc/filesystems  
### Linux VFS(Virtual Filesystem Switch)  
> Linux通过要给名为Virtual Filesystem Switch的核心功能区读取它认识的filesystem，所有使用者不需要关心每个partition上面的filesystem是什么  
  
## XFS文件系统  
> Linux文件系统从ext4到xfs的原因:ext文件系统支持度最广，但是格式化很慢  
  
xfs本身就是一个日志式文件系统，适合用了做高容量磁盘和高效能文件系统，ext4具有的功能，xfs都可以具备  
### xfs文件系统规划  
1. 资料区(data section)：和ext的block group差不多，用于存放inode/data block/superblock等信息，这个资料区也分为很多个存储区群组(allocation group),用存放文件系统需要的信息  
每个存储区群组(allocation group,AG)中包含的信息：  
* 整个文件系统的superblock  
* 剩余空间的管理机制  
* inode的分配与追踪  
**inode和block都是系统需要时，才动态分配，所有格式化的动作很快，xfs文件系统中，block的容量可以分配512bytes-64k（但是由于内存控制每一页的容量的关系，最高能使用的block还有只有4k而已），inode的大小为256bytes-2m**  
2. 文件系统活动登录区(log section)：用来记录文件系统的变化，类似有ext中的日志区，文件的变化在这里记录下来，知道该变化完整的写到资料区，这个记录才被终结，如果出现异常情况，系统会拿这个登录区来进行检验  
3. 即时运作区(realtime section)：当有文档建立时，xfs会在这个区段内找到一个到数个extend区块，将文档放置到这些区块内，等分配完之后，再写入data section中的inode和block去，extend的大小为4k-1G  
**使用“xfs_info 挂载点”指令可查看xfs文件系统中的superblock中的内容**