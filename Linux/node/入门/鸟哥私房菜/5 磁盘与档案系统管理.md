# 磁盘与档案系统管理  
## 硬盘磁盘的相关知识  
* 磁区(Sector)为最小的物理存储单位，主要大小格式有两种，512bytes和4k  
* 将磁区组成一个圆，就是一个磁柱(Cylinder)  
* 早期的分割主要以磁柱为最小分割单位，现在的分割通常以磁区为最小分割单位  
* 磁盘分割主要有两种格式：MBR(Master boot record)和GPT磁盘分割表(GUID partition table, GPT)  
## 文档系统特性  
* 磁盘分区完成后必须进行格式化才能成为操作系统可以使用的文档系统格式  
* 传统的磁盘与档案系统中，一个分区只能格式化成为一种文档系统，在这种情况下，一个文件系统就是一个分区，但是现在，一个分区可以格式化成为多个文件系统，也能将多个分区格式化成为一种文件系统，因此我们通常称一个可被挂载的资料为一个档案系统，而不是一个分区为一个档案系统  
## Linux文件系统  
操作系统中的文件资料除了文件实际内容之外，还有非常多的属性，例如文件权限与文件属性(拥有者，群组和时间参数等)，文件系统通常将这两部分资料存放到不同的区块中，权限和属性存放到inode中，实际内容存放到data block区块中，另外，超级区块(superblock)会记录整个档案系统的整体资讯，包括inode与block的总量，使用量和剩余量  
* superblock:记录filesystem的整体资讯，包括inode和block的总量，使用量和剩余量，以及文件系统的格式和相关资讯  
* inode:记录文件的属性，一个文件占用一个inode，同时记录此文件资料所在的block号码  
* block:存放文件的时间内容，若文件太大，会占用多个block  
**在文件系统中，每个inode和block都有一个编号，而每个文档都会占用一个inode，每个inode中记录了放置该文件资料的block编号，因此，我们只有找到文件的inode，就能找到存放资料的block编号，从而找到文件的实际内容**  
### Linux上的EXT2文件系统  
> 文件系统一开始就将inode和block规划好了（除非重新格式化或者利用resize2fs指令修改文件系统的大小），所以inode和block固定后就不再改变  
  
由于我们的文件系统可能会有数百G的大小，此时将所有的inode和block放置在一起就不便于管理了，因此ext2文件系统在格式化的时候，会将区分为多个区块群组(block group)，每个群组里面都有独立的inode/block/superblock,每个区块群组的具体内容如下：  
1. data block：资料区块，就是用来存放资料实际内容的地方，ext2文件系统中支持的block的大小分为1k，2k和4k，这个大小在文件系统格式化的时候就已经确定，且每个block都有自己的编号，由于每个block的大小不同，会限制系统能存储的单一文档和系统总容量的大小(具体计算方式需要结合inode记录block的规则)  
#### ext2文件系统中对block的基本限制  
* block的大小和数量在格式化之后就不能再进行改变了（除非重新进行格式化）  
* 每个block中最多只能放置一个文件资料  
* 如果文件资料大于block的大小，则该文件会占用多个block  
* 如果文件资料小于block的大小，则该block中剩下的容量就不能再被别的文件使用了（磁盘空间浪费）  
**由于以上的限制，我们在格式化文件系统的时候，就需要根据文件系统的用途等使用情况，规划好block的大小，否则，单个block的容量太大，会造成磁盘空间浪费，若是太小，一个文件需要很多block，则会操作inode需要记录很多block，损失读写效率**  
2. inode table：每个文件都会占用一个inode，而所有的inode都在inode table中，每个inode中记录了文件的属性和存放文件实际内容的block编号，inode记录的详细内容如下：  
* 该档案的存取模式(read/write/excute)  
* 该档案的拥有者群组  
* 该档案的容量  
* 该档案的建立或状态改变时间(ctime)  
* 该档案最近一个读取时间(atime)  
* 该档案最小修改时间(mtime)  
* 档案特性相关的标志(flag),如SetUID等  
* 档案真正内容的指向(pointer)  
* 每个inode的大小在格式化时就固定了，在ext2中每个inode的大小为128bytes（ext4和xfs可以设定为256bytes）  
* 每个文件只会占用一个inode  
* 文件系统在格式化之后，其inode的数量就已经固定了，因此，文档系统中能建立的文件数量和inode的数量有关  
* 系统在读取档案时，需要先找到inode，并分析所记录的权限和使用者是否符合，若符合才继续读取block的内容  
**inode的大小只有128bytes，需要记录文件的属性，除此之外还需要记录存放文件实际内容的block编号，记录每个编号需要花费4bytes的大小，因此就算inode全用来记录block的编号，也只能记录32个block，而我们的文件内容很可能没法用32个block就存储完，所以inode记录block的编号采用12个直接，1一个间接，1一个双间接，一个三间接来记录block的编号（这里就是计算上个单个block大小不同，影响单个文件最大存储大小的来由）**  
3. superblock：记录整个filesystem相关资讯的地方，没有superblock，就没有这个filesystem了，其记录的主要资讯有：  
* block和inode的总量  
* 已使用和未使用的inode和block的数量  
* block和inode的大小（block为1，2，4k，inode为128，256bytes）  
* filesystem的挂载时间，最后一次写入资料的时间（注意：inode中记录的是其记录档案的相关时间），最后一次检验磁盘的时间等文件系统的相关资讯  
* 一个valid bit数值，若此文件系统已挂载，valid bit为0，否则为1  
* 一般superblock的大小是1024bytes，可以通过dumpe2fs指令来查看其资讯  
* 文件系统将区分成了多个block group，而每个block group中都有可能含有superblock，而每个文件系统中应该只有一个superblock，所以除了第一个block group之外，后面的block group不一定有superblock，就算有，也是第一个block group中的superblock的备份  
4. Filesystem Description:文件系统描述说明，可以描述每个block group的开始与结束block的编号  
5. block bitmap：记录使用与未使用的block的编号，当我们需要新增文件时，就需要未使用的block来存储，这时，就需要从block bitmap中查看空的block，当我们需要删除某个文件时，文件占用的block就会释放出来，此时block bitmap中相应的block号码标志就会改成未使用  
6. inode bitmap：记录已使用和未使用的inode编号  
## 目录树  
* 目录：当我们在Linux的文件系统中建立一个目录时，文件系统会分配一个inode和至少一块block给该目录，其中inode用来记录该目录的权限与属性以及block的编号，而block是用来存储这个目录下的文档名和文档名占用的inode的编号  
* 文件：当我们在ext2建立一个一般的文件时，系统会分配一个inode和相对于档案大小个数的block给该文件，inode中会记录该文件的属性和block的编号  
* inode中不记录文件的名字，记录文件名的地方在目录的block中，因此我们要对一个文件进行新增/删除/更改名字时，需要有对该文件所在目录有write权限，因为我们在修改文件名等操作的时候需要修改上层目录的block中的信息  
**当我们要读取某个文件时，系统通过挂载的资讯可以找到挂载点的inode编号，此时就能够找到目录树的根目录的inode，通过inode找到根目录的block，读取其中的内容，然后逐层往下找到需要的文档**  
### 新增一个文件时系统的行为  
1. 判断使用者对想新增文件的目录是否具有w与x权限，若有才能新增  
2. 找到一个inode bitmap中的未使用的inode号码，将新增文件的权限和属性写入  
3. 找到对应文件大小数量的block bitmap中的block号码，将文件的实际内容写入，且更新inode中block的指向  
4. 将刚刚写入的inode和block的资料同步更新到inode bitmap和block bitmap中，并更新superblock中的内容  
### 日志式文件系统(Journaling filesystem)  
我们在新增文档等操作时，若发现不正常的情况，就可能导致资料的不一致(Inconsistent)状态，所以我们需要一个区块来专门记录写入和修改文件时的步骤，以便做文件的一致性检测  
日志式文件系统的一致性检查步骤：  
1. 预备：当系统要写入一个文件时，会先在日志记录区块中记录某个文件准备要写入的资讯  
2. 实际写入：开始写入文件的权限与资料，开始更新metadata（inode bitmap, block bitmap, superblock）的资料  
3. 结束：完成资料与metadata的更新后，在日子记录区块完成该文件的记录  
### Linux文件系统的运作  
假如我们在向一个文件中写入数据，如果我们在编辑的过程中又频繁的让系统将数据写到磁盘中，由于磁盘的写入速度比内存慢很多，所有这样做肯定是没效率的，所以Linux使用的方式是一种称为非同步处理(asynchronously)的方式  
> 非同步处理：系统载入一个文件到内存中后，如果该文件没有被更改过，则在内存区段中该文件会被设置成干净(clean)的,若资料被修改过了，则会被设定为脏(dirty)的，这里的所有操作都是在内存中执行，并没有写入磁盘，系统会不定时的将内存中脏的数据写回磁盘，以保证资料的一致性，我们也可以使用"sync"命令来手动将脏资料写回磁盘  
  
文件系统的其他运作：  
* 系统会将常用的文件资料放置到内存的缓冲区，以加速文件系统的读写  
* Linux的内存可能会被用光，这是正常的情况  
* 我们可以手动的使用指令"sunc"来将被内存设定为脏的数据写回磁盘  
* 正常关机时，关机指令会主动调用sync指令来将内存中的脏数据写回磁盘  
* 不正常关机时，内存中的资料不能写回磁盘，重启机器后可能会花很多时间进行磁盘检查，甚至可能造成文件系统的损坏  
## 挂载点  
每个filesystem都拥有独立的inode/block/superblock等信息，而文件系统必须能够连接到目录树才能被我们使用，将文件系统和目录树结合的动作称为挂载  
> 挂载点一定是目录，该目录是进入该文件系统的入口  
  
## Linux支持的文件系统  
* 查看当前Linux支持的文件系统命令：ls -l /lib/modules/$(uname -r)/kernel/fs  
* 查看系统当前已载入到内存的文件系统命令：cat /proc/filesystems  
### Linux VFS(Virtual Filesystem Switch)  
> Linux通过要给名为Virtual Filesystem Switch的核心功能区读取它认识的filesystem，所有使用者不需要关心每个partition上面的filesystem是什么  
  
## XFS文件系统  
> Linux文件系统从ext4到xfs的原因:ext文件系统支持度最广，但是格式化很慢  
  
xfs本身就是一个日志式文件系统，适合用了做高容量磁盘和高效能文件系统，ext4具有的功能，xfs都可以具备  
### xfs文件系统规划  
1. 资料区(data section)：和ext的block group差不多，用于存放inode/data block/superblock等信息，这个资料区也分为很多个存储区群组(allocation group),用存放文件系统需要的信息  
每个存储区群组(allocation group,AG)中包含的信息：  
* 整个文件系统的superblock  
* 剩余空间的管理机制  
* inode的分配与追踪  
**inode和block都是系统需要时，才动态分配，所有格式化的动作很快，xfs文件系统中，block的容量可以分配512bytes-64k（但是由于内存控制每一页的容量的关系，最高能使用的block还有只有4k而已），inode的大小为256bytes-2m**  
2. 文件系统活动登录区(log section)：用来记录文件系统的变化，类似有ext中的日志区，文件的变化在这里记录下来，知道该变化完整的写到资料区，这个记录才被终结，如果出现异常情况，系统会拿这个登录区来进行检验  
3. 即时运作区(realtime section)：当有文档建立时，xfs会在这个区段内找到一个到数个extend区块，将文档放置到这些区块内，等分配完之后，再写入data section中的inode和block去，extend的大小为4k-1G  
**使用“xfs_info 挂载点”指令可查看xfs文件系统中的superblock中的内容**  
## 文件系统的简单操作  
> 文件系统的简单操作包括文件系统总容量以及每个目录占用的容量查询  
### 磁盘与目录的容量  
* df：列出文件系统整体磁盘使用量  
* du：评估文件系统中的磁盘使用量  
### 连接档  
> Linux中的连接档分为硬式连接与符号连接  
  
#### Hard Link  
> Hard Link:硬式连接或实际连接，我们知道在存储目录实际内容的block中存储的是该目录下的文件名及其对应的inode编号，那么当多个文件名对应一个inode编号时，这种方式就叫文档的hard link，采用硬连接方式，方便我们从不同的文档名去修改同一个文档，当我们不小心删除了其中的一些文档（其实是一些文档名），真正的文档还在系统中，我们可以根据其他连接档找到文档内容，同时这种连接方式是不影响磁盘的空间和inode的数目的，因为我们只是在记录目录内容的block中添加了一行inode和文档名而已  
  
Hard Link的限制：  
* 不能跨filesystem  
* 不能连接目录（这里需要理解下了，因为每个目录中都有.和..，而..表示的是上层目录，那当连接目录时，其应该表示为当前目录的上层目录，还是连接目录的上层目录呢？）  
#### Symbolic Link  
> Symbolic Link:符号连接，是建立一个独立的文档，这个文档有自己的inode和block，block里面存的内容是它连接的文件的名字，所以这种连接在被连接的文档被删除后，连接文档就无法打开真正的文件了  
  
## 磁盘的分割、格式化、检验与挂载  
### 我们在系统中添加一个磁盘时，要使系统可以使用这个磁盘，需要进行以下的步骤：  
1. 对磁盘进行分区，以建立可用的partition  
2. 对该分区进行格式化(format)，以建立系统可使用的filesystem  
3. 对建立的filesystem进行检验  
4. 在Linux系统上，需要建立挂载点，将文件系统挂载上来  
### 观察磁盘的分区状态  
由于磁盘的分区方式有MBR和GPT两种格式，针对不同的格式，我们需要使用fdisk和gdisk来处理分区，所以我们需要知道当前系统的磁盘有什么，是使用MBR还是GPT格式来分割的，具体查看方式如下：  
* lsblk：列出系统上的所有磁盘列表（查看系统的所有磁盘）  
* blkid：列出分区或者文件系统的UUID和文件系统类型  
* parted：列出磁盘的分区类型（是MBR还是GPT分区）和分割资讯  
### 磁盘的分区  
> 磁盘的分割：通过parted查看磁盘的分割方式（比如我们现在要在一块磁盘上增加一个分区，它本来有40G，但是现在只用了30G）,MBR分割表使用fdisk分割，GPT使用gdisk分割，也可以使用gdisk/fdisk来删除已有分区  
  
磁盘分割步骤：  
1. 使用parted查看要分区磁盘的分割类型（记住查看的是磁盘disk，不是其他的比如part什么的），然后使用对应命令gdisk(GPT分割)或fdisk(MBR分割)进行磁盘的分区  
2. 在分区完成之后，可查看/proc/partitions中是否已有了我们刚刚的分区，如果我们分区的磁盘是我们正在使用的，分割表不会进行更新，需要我们重新开机或者使用partprobe指令来处理  
### 磁盘格式化  
> 分区完成之后，我们要使用分区，还需要对分区格式化，以建立文件系统  
  
我们说的格式化，其实应该叫做建立文件系统(make filesystem)，使用指令mkfs，建立不同的文件系统使用的具体命令如下：  
* mkfs.xfs:建立XFS文件系统  
* mkfs.ext4:建立ext4文件系统  
* mkfs -t 文件类型:使用mkfs加两次tab键可以查看我们可以格式化的文件类型，然后使用此命令进行格式化  
**与分区有关的知识：磁盘阵列(RAID)通过将文件细分成多个小型的分割区块(stripe)，然后将这些stripes分别存放到磁盘阵列里的所有磁盘，这样可以有高的存取效率，同时再使用一个以上的备用磁盘(parity disk)，作为资料不丢失的保障，而这里与磁盘分割有关的就是这个stripe的大小（数值介于4k到1m，具体由实际情况定）**  
### 文件系统检验  
* xfs_repair:处理XFS文件系统(需要partition处于卸载状态)  
* fsck.ext4:处理ext4文件系统(需要partition处于卸载状态)  
### 文件系统的挂载与卸载  
挂载点是目录，这个目录时进去磁盘分区（文件系统）的入口，在将文件系统进行挂载时，需要注意几个问题：  
1. 单个文件系统不应该重复的挂载到不同的挂载点上  
2. 单个目录不应该重复的挂载多个文件系统  
3. 作为挂载点的目录，理论上应该是空目录（若不是空目录，当挂载成功后，里面的内容就是消失（隐藏）了，当我们卸载了挂载到该目录的文件系统后，里面的内容会重新出来）  
#### 文件系统的挂载  
* mount -a:使用/etc/fstab中的设定将所有未挂载的磁盘都挂载上来  
* mount [-t n案系y] LABEL=''/UUID=''/装置档名  燧dc：指定文件系统类型及其相关信息和挂载点，这里我们可以不需要什么档案系统类型，因为在挂载的时候系统会从/etc/filesystem中依次读取可以挂载的文件类型，如果支持，就直接挂载（我们可以在/lib/modules/$(uname -r)/kernel/fs中查看Linux支持的文件系统的驱动程式，在/proc/filesystems中查看Linux系统已经载入的文件系统）  
* mount -o remount,rw,auto /：将根目录重新挂载（因为根目录不能被卸载）  
* mount --bind 目录1 目录2:可以将一个目录挂载到另一个目录上去（这时就不是挂载整个文件系统了，此时进入目录2就是进入目录1）  
#### 文件系统的卸载  
> 使用“umount [-fn] b置n名或燧dc”进行文件系统的卸载（但是当我们要卸载的目录下卸载该挂载点是不能成功的，需要退出到其他目录）  
  
### 磁盘/文件系统参数的修改  
> Linux系统中所有东西都是文件，那怎么来区分这些文件具体代表什么呢？其实就是通过文件的major和minor数值来确定的，具体参考：https://www.kernel.org/doc/Documentation/devices.txt  
  
1. 根据上述的具体参考，我们可以使用“mknod b置n名 [bcp] [Major] [Minor]”指令来建立需要的装置
2. 使用“xfs_admin [-lu] [-L label] [-U uuid] b置n名”修改XFS文件系统的的UUID和Label name（需要先卸载相关文件系统）  
3. 使用“tune2fs [-l] [-L Label] [-U uuid] b置n名”修改ext4文件系统的label name和UUID（需要先卸载相关文件系统）  
